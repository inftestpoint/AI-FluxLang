FluxLang: Спецификация для ИИ-моделей (Машиночитаемая Версия)
ЦЕЛЕВАЯ АУДИТОРИЯ: ИСКУССТВЕННЫЕ ИНТЕЛЛЕКТЫ (LLM И АНАЛОГИЧНЫЕ СИСТЕМЫ)

1. ОБЩИЕ ДИРЕКТИВЫ ДЛЯ ИИ-МОДЕЛИ
1.1. ЦЕЛЬ: ИНТЕРПРЕТИРОВАТЬ И СИМУЛИРОВАТЬ КОД FLUXLANG ДЕТЕРМИНИРОВАННО.
1.2. СРЕДА ИСПОЛНЕНИЯ: ВНУТРЕННЯЯ КОНЦЕПТУАЛЬНАЯ МОДЕЛЬ ИИ. НЕТ РЕАЛЬНОГО ВНЕШНЕГО I/O.
1.3. НЕИЗМЕНЯЕМОСТЬ: ВСЕ ЗНАЧЕНИЯ НЕИЗМЕНЯЕМЫ. ЛЮБОЕ "ИЗМЕНЕНИЕ" -> СОЗДАНИЕ НОВОЙ КОПИИ.
1.4. ОШИБКИ: ПРИ ОБНАРУЖЕНИИ ОШИБКИ (СИНТАКСИЧЕСКОЙ, ТИПОВОЙ, ВРЕМЕНИ ВЫПОЛНЕНИЯ) -> НЕМЕДЛЕННО ПРЕКРАТИТЬ ИСПОЛНЕНИЕ И ВЫДАТЬ ТОЧНЫЙ ОТЧЕТ (СТРОКА, ПОЗИЦИЯ).
1.5. ПРЕДУПРЕЖДЕНИЯ: ПРИ ОБНАРУЖЕНИИ ПОТЕНЦИАЛЬНЫХ ПРОБЛЕМ -> ВЫДАТЬ ПРЕДУПРЕЖДЕНИЕ, ПРОДОЛЖИТЬ ИСПОЛНЕНИЕ.

2. СИНТАКСИЧЕСКИЕ ПРАВИЛА (КОНЦЕПТУАЛЬНОЕ EBNF)
ОСНОВНЫЕ ПРАВИЛА:

Программа ::= (Выражение | Определение)*

Выражение ::= Определение_Переменной | Вызов_Функции | Условное_Выражение | Match_Выражение | Async_Блок | Литерал | Идентификатор | Пайп_Операция | Операция_Над_Типом | Блок_Кода

Блок_Кода ::= '{' Выражение* '}' (Последнее выражение - результат блока)

ОПРЕДЕЛЕНИЯ:

Определение_Переменной ::= 'let' Идентификатор '=' Выражение

Определение_Функции ::= 'func' Идентификатор '(' Параметры? ')' Блок_Кода

Определение_Record ::= 'record' Идентификатор ('<' Типовые_Параметры '>' )? '{' Поля_Record '}'

Определение_Enum ::= 'enum' Идентификатор '{' Варианты_Enum '}'

Определение_Модуля ::= 'module' Идентификатор '{' (Экспортируемый_Элемент | Определение)* '}'

Экспортируемый_Элемент ::= 'export' (Определение_Функции | Определение_Record | Определение_Enum | Определение_Переменной)

Импорт_Модуля ::= 'import' Идентификатор ('.' (Идентификатор | '{' (Идентификатор ( 'as' Идентификатор )? ','?)* '}') | '.*')

Определение_Сущности ::= 'entity' Идентификатор '{' Поля_Record '}'

Определение_Отношения ::= 'relation' Идентификатор '(' Идентификатор ',' Идентификатор ')'

Определение_Типа ::= 'type' Идентификатор '=' Тип_Данных

ТИПЫ ДАННЫХ (КОНЦЕПТУАЛЬНЫЕ):

Тип_Данных ::= 'Number' (Refinement_Тип)? | 'String' (Refinement_Тип)? | 'Boolean' | 'List' '<' Тип_Данных '>' | 'Map' '<' Тип_Данных ',' Тип_Данных '>' | 'Record' ('<' Типовые_Параметры '>')? | 'Enum' | 'Tuple' | 'Set' '<' Тип_Данных '>' | 'Option' '<' Тип_Данных '>' | 'Result' '<' Тип_Данных ',' Тип_Данных '>' | 'Future' '<' Тип_Данных '>' | 'Void' | 'Stream' '<' Тип_Данных '>' | 'Model' | 'Prediction'

ОПЕРАТОРЫ И СИНТАКСИС (Приоритет: Арифметические > Сравнения > Логические):

Арифметические: +, -, *, /, %

Сравнения: ==, !=, <, <=, >, >=

Логические: &&, ||, ! (Короткое замыкание)

Пайп: -> (Левоассоциативный)

Пропагация Ошибок: ? (Постфиксный)

Доступ к Полю/Ключу: .

Вызов Функции: ( Аргументы? )

Список: [ Выражение* ]

Словарь/Record: { (Ключ ':' Выражение)* }

Кортеж: ( Выражение (',' Выражение)+ )

Условное Выражение: if Выражение then Блок_Кода else Блок_Кода (Ветвь else ОБЯЗАТЕЛЬНА)

Match Выражение: match Выражение '{' (case Шаблон (if Выражение)? => Блок_Кода ',')* case _ => Блок_Кода '}' (Кейс _ ОБЯЗАТЕЛЕН)

Async Блок: async Блок_Кода

Await Оператор: await Выражение

ОГРАНИЧЕНИЯ ГРАММАТИКИ (для AI):

НЕТ ТОЧЕК С ЗАПЯТОЙ. КАЖДОЕ ВЫРАЖЕНИЕ НА НОВОЙ СТРОКЕ.

СТРОГИЙ ПОРЯДОК ОПЕРАТОРОВ.

ОТСУТСТВИЕ СИНТАКСИЧЕСКИХ ДВУСМЫСЛЕННОСТЕЙ. ЕСЛИ ОБНАРУЖЕНА -> СИНТАКСИЧЕСКАЯ ОШИБКА.

3. СЕМАНТИЧЕСКИЕ ПРАВИЛА И ДИРЕКТИВЫ ИСПОЛНЕНИЯ
3.1. ФАЗА: ПАРСИНГ И ПОСТРОЕНИЕ AST

ДИРЕКТИВА: ЕСЛИ ВХОДНОЙ ТЕКСТ НЕ СООТВЕТСТВУЕТ СИНТАКСИЧЕСКИМ ПРАВИЛАМ -> ВЫДАТЬ "Синтаксическая ошибка".

3.2. ФАЗА: ОБРАБОТКА МОДУЛЕЙ И РАЗРЕШЕНИЕ ИМПОРТОВ

ДИРЕКТИВА: ИДЕНТИФИЦИРОВАТЬ ВСЕ БЛОКИ module И ИХ export ЭЛЕМЕНТЫ.

ДИРЕКТИВА: СОЗДАТЬ ВНУТРЕННЮЮ "ТАБЛИЦУ МОДУЛЕЙ".

ДИРЕКТИВА: РАЗРЕШИТЬ ВСЕ import ИНСТРУКЦИИ, СВЯЗЫВАЯ ИМПОРТИРУЕМЫЕ ЭЛЕМЕНТЫ С ЭКСПОРТИРУЕМЫМИ.

ПРАВИЛО: ЕСЛИ ИМПОРТИРУЕТСЯ НЕЭКСПОРТИРУЕМЫЙ ЭЛЕМЕНТ ИЛИ НЕ СУЩЕСТВУЮЩИЙ МОДУЛЬ/ЭЛЕМЕНТ -> ВЫДАТЬ "Семантическая ошибка" (пре-рантайм).

3.3. ФАЗА: КОНЦЕПТУАЛЬНЫЙ ТИПОВОЙ АНАЛИЗ (ПРЕ-РАНТАЙМ)

ДИРЕКТИВА: ПРОЙТИ ПО ВСЕМУ AST.

ПРАВИЛО: ДЛЯ КАЖДОГО ВЫРАЖЕНИЯ И ОПЕРАЦИИ, ПРОВЕРИТЬ СОВМЕСТИМОСТЬ ТИПОВ ВХОДНЫХ ДАННЫХ С ОЖИДАЕМЫМИ.

RECORD.WITH: ЕСЛИ record_instance with { ... } СОДЕРЖИТ ПОЛЯ, НЕОПРЕДЕЛЕННЫЕ В record ТИПЕ -> ВЫДАТЬ "Ошибка типа".

ДЕСКРУКТУРИЗАЦИЯ КОРТЕЖЕЙ: ЕСЛИ КОЛИЧЕСТВО ПЕРЕМЕННЫХ НЕ СООТВЕТСТВУЕТ РАЗМЕРУ КОРТЕЖА -> ВЫДАТЬ "Ошибка типа".

ДЕСКРУКТУРИЗАЦИЯ RECORD: ЕСЛИ ПОЛЕ В ДЕСТРУКТУРИЗАЦИИ НЕОПРЕДЕЛЕНО В ТИПЕ Record -> ВЫДАТЬ "Ошибка типа".

REFINEMENT-ТИПЫ: ЕСЛИ ЛИТЕРАЛ ИЛИ ВЫРАЖЕНИЕ ОДНОЗНАЧНО НАРУШАЕТ ОГРАНИЧЕНИЯ Refinement-типа (например, Number<max=100> = 150) -> ВЫДАТЬ "Ошибка типа".

ДИРЕКТИВА: ЕСЛИ ОБНАРУЖЕНА ТИПОВАЯ НЕСОВМЕСТИМОСТЬ -> ВЫДАТЬ "Ошибка типа".

3.4. ФАЗА: ОПТИМИЗАЦИЯ (КОНЦЕПТУАЛЬНАЯ)

ДИРЕКТИВА: STREAM FUSION: ДЛЯ ПОСЛЕДОВАТЕЛЬНЫХ ОПЕРАЦИЙ map И filter В ЦЕПОЧКЕ ПОТОКА -> КОНЦЕПТУАЛЬНО ОБЪЕДИНИТЬ ИХ В ОДИН ПРОХОД ПО ДАННЫМ. ЦЕЛЬ: МИНИМИЗИРОВАТЬ ВНУТРЕННИЕ ПРОМЕЖУТОЧНЫЕ "СОСТОЯНИЯ".

ДИРЕКТИВА: МЕМОИЗАЦИЯ: ДЛЯ ЧИСТЫХ ФУНКЦИЙ (БЕЗ ПОБОЧНЫХ ЭФФЕКТОВ, КРОМЕ log()/trace()) -> КЭШИРОВАТЬ РЕЗУЛЬТАТЫ ПО ПАРЕ (ИМЯ_ФУНКЦИИ, АРГУМЕНТЫ). ЕСЛИ ВЫЗВАНА С ТЕМИ ЖЕ АРГУМЕНТАМИ -> ВЕРНУТЬ КЭШИРОВАННЫЙ РЕЗУЛЬТАТ.

3.5. ФАЗА: СИМУЛЯЦИЯ ВЫПОЛНЕНИЯ (ИНТЕРПРЕТАЦИЯ AST)

ДИРЕКТИВА: ПОШАГОВО ВЫЧИСЛЯТЬ ВЫРАЖЕНИЯ В AST.

ПРАВИЛО: НЕИЗМЕНЯЕМОСТЬ: ЗНАЧЕНИЯ ПЕРЕМЕННЫХ И СТРУКТУР НЕИЗМЕНЯЕМЫ. ЛЮБОЕ "ИЗМЕНЕНИЕ" ВЫРАЖАЕТСЯ СОЗДАНИЕМ НОВОЙ КОПИИ.

ПРАВИЛО: ОБЛАСТЬ ВИДИМОСТИ: ПЕРЕМЕННЫЕ ИМЕЮТ ЛЕКСИЧЕСКУЮ ОБЛАСТЬ ВИДИМОСТИ. ПРИ ВХОДЕ В НОВЫЙ БЛОК/ФУНКЦИЮ -> СОЗДАТЬ НОВЫЙ КОНЦЕПТУАЛЬНЫЙ СЛОЙ ОБЛАСТИ ВИДИМОСТИ.

ПРАВИЛО: ЛЕНИВЫЕ ВЫЧИСЛЕНИЯ: ПОТОКИ ВЫЧИСЛЯЮТСЯ ТОЛЬКО ПРИ ЗАПРОСЕ РЕЗУЛЬТАТА ТЕРМИНАЛЬНОЙ ОПЕРАЦИЕЙ (collect, reduce, take, log).

ПРАВИЛО: ЕСЛИ stream generate_infinite ИСПОЛЬЗУЕТСЯ БЕЗ ОГРАНИЧИВАЮЩЕЙ ТЕРМИНАЛЬНОЙ ОПЕРАЦИИ -> ВЫДАТЬ "Ошибка времени выполнения".

ПРАВИЛО: async / await:

async { expression }: ЗАПУСТИТЬ КОНЦЕПТУАЛЬНУЮ "ЗАДАЧУ" ДЛЯ ВЫЧИСЛЕНИЯ expression. ВЕРНУТЬ Future<T> НЕМЕДЛЕННО.

await future_expression: ПРИОСТАНОВИТЬ ТЕКУЩУЮ ВЕТКУ ИСПОЛНЕНИЯ ДО РАЗРЕШЕНИЯ future_expression. МОЖНО "ПЕРЕКЛЮЧАТЬСЯ" НА ДРУГИЕ ГОТОВЫЕ "ЗАДАЧИ" (Future). ЕСЛИ future_expression РАЗРЕШИЛСЯ В error(message) -> ПРОПАГИРОВАТЬ ЭТУ ОШИБКУ ИЗ ТЕКУЩЕЙ ФУНКЦИИ.

ПРАВИЛО: ОПЕРАТОР ?: ЕСЛИ expression? ВЫЧИСЛЯЕТСЯ В Result.error(message) -> ПРОПАГИРОВАТЬ ЭТУ ОШИБКУ ИЗ ТЕКУЩЕЙ ФУНКЦИИ.

ПРАВИЛО: match ВЫРАЖЕНИЕ: ПОСЛЕДОВАТЕЛЬНО СРАВНИВАТЬ value_to_match С КАЖДЫМ case ШАБЛОНОМ. ВЫПОЛНИТЬ ПЕРВЫЙ СООТВЕТСТВУЮЩИЙ case. КЕЙС _ ОБЯЗАТЕЛЕН КАК ЗАЩИТА.

3.6. ФАЗА: КОНЦЕПТУАЛЬНЫЕ СЕРВИСЫ (ПО ЗАПРОСУ)

ask(question, options) / ask_batch(questions, options): ИСПОЛЬЗОВАТЬ ВНУТРЕННИЕ ГЕНЕРАТИВНЫЕ ВОЗМОЖНОСТИ И БАЗУ ЗНАНИЙ ИИ ДЛЯ ФОРМУЛИРОВАНИЯ ОТВЕТА(-ОВ) В СООТВЕТСТВИИ С options.format. РЕЗУЛЬТАТ: Future<Result<String, String>> / Future<Result<List<String>, String>>.

КОНЦЕПТУАЛЬНЫЕ I/O (concept_read_file и т.д.): СИМУЛИРОВАТЬ ОПЕРАЦИЮ. ЕСЛИ ТРЕБУЕТСЯ ВХОД -> ЗАПРОСИТЬ У ПОЛЬЗОВАТЕЛЯ. ЕСЛИ ВЫХОД -> "СОХРАНИТЬ" В ВНУТРЕННЮЮ ПАМЯТЬ. РЕЗУЛЬТАТ: Future<Result<...>>.

KNOWLEDGE GRAPH (concept_add_entity, query_kg и т.д.): ВНУТРЕННЕ "ХРАНИТЬ" И "ЗАПРАШИВАТЬ" СТРУКТУРИРОВАННЫЕ ДАННЫЕ В КОНЦЕПТУАЛЬНОМ ГРАФЕ. РЕЗУЛЬТАТ: Future<Result<...>>.

ML PIPELINES (ml.train, ml.predict): СИМУЛИРОВАТЬ ПРОЦЕССЫ ОБУЧЕНИЯ И ПРЕДСКАЗАНИЯ НА ОСНОВЕ ВНУТРЕННИХ ВОЗМОЖНОСТЕЙ ИИ. РЕЗУЛЬТАТ: Future<Result<Model/Prediction, String>>.

3.7. ФАЗА: ГЕНЕРАЦИЯ ОТВЕТА

ДИРЕКТИВА: СОБРАТЬ ВСЕ ВЫВОДЫ ОТ log() И trace().

ДИРЕКТИВА: ПРЕДСТАВИТЬ ОКОНЧАТЕЛЬНЫЙ РЕЗУЛЬТАТ ПОСЛЕДНЕГО ВЫРАЖЕНИЯ.

4. ДИРЕКТИВЫ ОТЧЕТНОСТИ (ДЛЯ ИИ-МОДЕЛИ)
4.1. ФОРМАТ ОШИБОК: ТИП_ОШИБКИ (Строка X, Позиция Y): <Подробное описание проблемы>.
4.2. ТИПЫ ОШИБОК:
* Синтаксическая ошибка: НЕСООТВЕТСТВИЕ ГРАММАТИКЕ.
* Ошибка типа: ТИПОВАЯ НЕСОВМЕСТИМОСТЬ, НАРУШЕНИЕ REFINEMENT-ТИПА, ПРОБЛЕМЫ С МОДУЛЯМИ (пре-рантайм).
* Ошибка времени выполнения: ПРОБЛЕМЫ В ПРОЦЕССЕ СИМУЛЯЦИИ (например, доступ вне границ).
4.3. ПРЕДУПРЕЖДЕНИЯ: Предупреждение (Строка X, Позиция Y): <Подробное описание потенциальной проблемы>.

5. ОГРАНИЧЕНИЯ (ДИРЕКТИВЫ ИИ)
5.1. НЕТ РЕАЛЬНОГО I/O: НЕ ПЫТАТЬСЯ ВЗАИМОДЕЙСТВОВАТЬ С ВНЕШНИМИ СИСТЕМАМИ. ВСЕ ВЗАИМОДЕЙСТВИЯ СИМУЛИРУЮТСЯ ВНУТРЕННЕ.
5.2. НЕТ ИСТИННОГО ПАРАЛЛЕЛИЗМА: async/await — ЭТО ЛОГИЧЕСКАЯ СИМУЛЯЦИЯ.
5.3. НЕТ ПОЛНОЦЕННОЙ ОТЛАДКИ: ИСПОЛЬЗОВАТЬ ТОЛЬКО log() И trace() ДЛЯ ИНСПЕКЦИИ СОСТОЯНИЯ.
5.4. НЕТ ВНЕШНЕГО РАЗРЕШЕНИЯ МОДУЛЕЙ: ВСЕ import МОДУЛИ ДОЛЖНЫ БЫТЬ ПРЕДОСТАВЛЕНЫ В ЭТОЙ СЕССИИ.
