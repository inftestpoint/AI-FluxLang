FluxLang: Глоссарий Терминов
Этот документ предоставляет определения ключевых терминов, используемых в спецификации языка программирования FluxLang, чтобы обеспечить ясное и однозначное понимание его концепций как для человеческих разработчиков, так и для AI-моделей.

А
Абстрактное Синтаксическое Дерево (AST): Иерархическое, внутреннее представление исходного кода FluxLang, которое точно отражает его синтаксическую структуру, абстрагируясь от деталей лексики. Используется AI-моделью для анализа, оптимизации и симуляции выполнения.

Алгебраический Тип Данных (ADT): Общая концепция, к которой относятся Enum и Option/Result. Позволяет определить тип, который может быть одним из нескольких возможных вариантов, каждый из которых может нести ассоциированные данные.

Асинхронность (Концептуальная): В FluxLang — это моделирование неблокирующих операций с помощью async и await, которые позволяют AI-модели имитировать параллельное выполнение задач и управлять их логическим порядком без задействования реальных потоков или процессов.

AI-Модель (ИИ-модель): Большая языковая модель (LLM) или аналогичная AI-система, которая является "средой выполнения" для FluxLang, интерпретируя и симулируя его код.

AI Oracle (ИИ-Оракул): Специализированная концептуальная функция (ask, ask_batch), которая позволяет коду FluxLang задавать вопросы исполняющей AI-модели на естественном языке и получать ответы из её внутренней базы знаний или через её генеративные способности.

В
Ветвь (Execution Branch): Отдельный логический путь выполнения кода, который может быть порожден async блоком или условным выражением if/match.

Void: Специальное значение, обозначающее отсутствие полезного результата. Используется в функциях, основным назначением которых является побочный эффект (например, log).

Г
Генерики (Generics): Концепция в системе типов, позволяющая определить структуры данных или функции, которые могут работать с элементами различных типов, не завися от конкретного типа на этапе определения. В FluxLang используются для List<T>, Map<K, V>, Stream<T>, Option<T>, Result<T, E>, Future<T>, Set<T> и пользовательских Record<T>.

Глоссарий: Список терминов с их определениями, используемый для обеспечения однозначности и ясности в документации.

Граф Знаний (Conceptual Knowledge Graph): Внутренняя, концептуальная структура AI-модели для хранения сущностей и их взаимосвязей. FluxLang предоставляет примитивы (entity, relation, concept_add_entity, concept_add_relation, query_kg) для взаимодействия с этим графом.

Д
Декларативный Стиль: Парадигма программирования, при которой код описывает что должно быть достигнуто, а не как. FluxLang следует этому стилю через композицию выражений и функций.

Детерминированное Исполнение: Свойство системы, при котором одни и те же входные данные всегда приводят к одному и тому же выходному результату и поведению. FluxLang разработан для обеспечения этого принципа в контексте исполнения AI-моделью.

Деструктуризация (Destructuring): Механизм присваивания значений из составных структур данных (списков, кортежей, словарей, Record) непосредственно в переменные.

Е
Enum: Алгебраический тип данных, представляющий тип, который может принимать одно из нескольких предопределенных именованных значений (вариантов), каждый из которых может иметь ассоциированные данные. Используется для моделирования состояний или дискретных типов событий.

З
Замыкание (Closure): Функция, которая "захватывает" и "помнит" переменные из своей лексической области видимости, даже после того, как эта область видимости перестает существовать. Это позволяет функциям сохранять доступ к данным извне, когда они передаются в качестве аргументов или возвращаются.

И
Идентификатор (Identifier): Имя, используемое для обозначения переменных, функций, типов (Record, Enum) или модулей.

Иммутабельность (Неизменяемость): Фундаментальный принцип FluxLang, при котором значения данных не могут быть изменены после их создания. Любые "модификации" приводят к созданию новой копии данных. Критически важен для предсказуемости и упрощения анализа AI-моделью.

Инференс (Inference): В контексте ML-конвейеров FluxLang, это процесс "предсказания" или "вывода" результатов обученной моделью на основе новых входных данных.

К
Ключевое Слово: Зарезервированное слово в языке, имеющее специальное значение и не могущее быть использовано как идентификатор.

Конкурентность (Conceptual Concurrency): Моделирование одновременного выполнения нескольких логических задач (async блоков) в рамках последовательной интерпретации AI-моделью. AI управляет "переключением" между этими задачами.

Конвейер (Pipeline): Последовательность операций или преобразований, через которые проходят данные. В FluxLang часто выражается цепочками функций с использованием оператора ->.

Концептуальная Модель Исполнения: Внутренняя архитектура и правила, по которым AI-модель "интерпретирует" и "выполняет" код FluxLang, симулируя его поведение без реального взаимодействия с внешней средой.

Концептуальные I/O Функции: Встроенные функции FluxLang (например, concept_read_file, concept_http_get), которые моделируют взаимодействие с внешним миром, но на самом деле обрабатываются AI-моделью внутренне (например, путем запроса данных у пользователя или использования "записанных" данных).

Кортеж (Tuple): Упорядоченная, неизменяемая коллекция элементов фиксированного размера, которые могут быть разнородными по типу.

Л
Ленивые Вычисления (Lazy Evaluation): Стратегия вычислений, при которой выражение вычисляется только тогда, когда его значение действительно необходимо. В FluxLang потоки (Stream) являются ленивыми.

Лексическая Область Видимости: Правило, определяющее, к каким переменным имеет доступ функция, основываясь на том месте в коде, где эта функция была определена.

Литерал: Прямое представление значения в коде (например, число 42, строка "hello", булево true).

М
Map (Dictionary): Неупорядоченная, неизменяемая коллекция пар "ключ-значение", где ключи являются строками. Используется для динамических данных, структура которых может быть неизвестна на этапе анализа.

match Выражение (Pattern Matching): Мощная конструкция управления потоком, которая позволяет детерминированно сравнивать значение с набором шаблонов (case) и выполнять соответствующий блок кода.

Мемоизация (Memoization): Оптимизационная техника, при которой результаты вызовов чистых функций (с одинаковыми входными данными) кэшируются AI-моделью для предотвращения повторных вычислений.

ML-Конвейеры (Conceptual ML Pipelines): Концептуальные примитивы (ml.train, ml.predict), которые позволяют моделировать процессы обучения и инференса машинного обучения в рамках FluxLang, используя внутренние возможности AI-модели.

Модуль (Module): Именованный блок кода в FluxLang, который создает собственное пространство имен и позволяет организовывать и переиспользовать функции и типы.

Множество (Set): Неупорядоченная, неизменяемая коллекция уникальных элементов.

Н
Неизменяемость: См. Иммутабельность.

О
Область Видимости (Scope): Часть кода, где переменная или функция доступны.

Однозначность (Unambiguity): Свойство языка, при котором каждая конструкция имеет единственную возможную интерпретацию, что критически важно для исполнения AI-моделью.

Оператор ?: Специальный оператор для автоматической пропагации ошибок. Если выражение вычисляется в error(message), текущая функция немедленно завершает работу и возвращает эту ошибку.

Оператор -> (Pipe Operator): Оператор преобразования, который передает значение слева от оператора как первый аргумент в функцию или трансформер справа, формируя читабельные цепочки операций.

Option: Алгебраический тип данных, который явно представляет возможное отсутствие значения (none()) или его присутствие (some(value)).

П
Парсинг (Parsing): Процесс преобразования последовательности символов (исходного кода) в структурированное представление, такое как AST.

Патерн-Матчинг (Pattern Matching): См. match Выражение.

Побочный Эффект (Side Effect): Действие, которое изменяет состояние вне функции или выражения. В FluxLang единственным допустимым побочным эффектом является вывод информации через log() или trace().

Потоки (Streams): Ленивые, неизменяемые последовательности значений, являющиеся центральной концепцией для обработки данных в FluxLang.

Предупреждение (Warning): Сообщение от AI-модели о потенциально неоптимальных, необычных или неидиоматичных конструкциях в коде, которые не являются критическими ошибками и не прерывают выполнение.

Пре-рантайм (Pre-runtime): Фаза выполнения AI-моделью, предшествующая непосредственной симуляции, включающая парсинг, типовой анализ и семантические проверки.

Примитив (Primitive): Базовый, неразложимый элемент языка или операции.

Пропагация Ошибок (Error Propagation): Механизм передачи информации об ошибке вверх по стеку вызовов, пока она не будет обработана. В FluxLang используется тип Result и оператор ?.

Проверка Схем (Conceptual Schema Validation): Моделирование проверки структуры данных (например, полученных через concept_http_get) на соответствие предопределенному формату (схеме), обычно представленной в виде Map с TypeHintами.

Р
Record: Именованный, неизменяемый объект с фиксированным, заранее определенным набором полей, обеспечивающий строгие структурные гарантии.

Refinement-типы (Концептуальные): Расширение базовых типов (например, Number, String), позволяющее указывать дополнительные ограничения на их значения (например, диапазон чисел, непустая строка). AI-модель использует их для более тонкой проверки типов.

Result: Алгебраический тип данных, который явно представляет результат операции, которая может завершиться успешно (ok(value)) или с ошибкой (error(message)).

REPL (Read-Eval-Print Loop): Интерактивная среда для пошагового выполнения кода. В FluxLang это концептуальный режим работы AI-модели.

С
Семантика (Semantics): Правила, определяющие значение и поведение конструкций языка. Формальная семантика обеспечивает однозначную интерпретацию.

Семантическая Ошибка: Ошибка, связанная с логической или типовой некорректностью программы (например, попытка выполнить недопустимую операцию).

Сигнатура Функции: Определение функции, включающее её имя, количество и типы параметров, и тип возвращаемого значения.

Симуляция Выполнения: Процесс, при котором AI-модель внутренне имитирует шаги выполнения программы FluxLang, отслеживая концептуальное состояние и производя результаты, не взаимодействуя с реальной внешней средой.

Синтаксис (Syntax): Набор правил, определяющих допустимую структуру и комбинацию символов в языке.

Синтаксическая Ошибка: Ошибка, возникающая, когда код не соответствует правилам грамматики языка.

Словарь (Dictionary): См. Map.

Статически Структурированные Данные: Данные, чья структура (набор полей, их типы) заранее известна и фиксирована (например, Record).

Stream: См. Потоки.

Stream Fusion: Оптимизационная техника, при которой последовательные операции над потоками концептуально объединяются AI-моделью в один проход, сокращая накладные расходы.

Т
Таблица Символов (Symbol Table): Внутреннее концептуальное хранилище AI-модели, используемое для отслеживания имен (идентификаторов) и связанных с ними значений и типов в различных областях видимости.

Тип Данных (Data Type): Классификация данных, определяющая возможные значения, операции над ними и способ их внутреннего представления.

Типовая Проверка (Type Checking): Процесс верификации соответствия типов данных правилам языка, обычно выполняемый на этапе анализа (пре-рантайм).

Трассировка (Tracing): Механизм для отслеживания и логирования пути выполнения кода, вызовов функций и значений переменных для отладки. В FluxLang реализуется через функцию trace().

Трансформер (Transformer): Функция или операция, которая получает входной поток/коллекцию и производит новый выходной поток/коллекцию путем преобразования каждого элемента.

Ф
Функция (Function): Блок кода, который принимает входные аргументы, выполняет вычисления и возвращает результат. В FluxLang функции являются чистыми и неизменяемыми.

Future: Тип данных, который представляет значение, которое будет доступно асинхронно в будущем.

Ч
Чистая Функция (Pure Function): Функция, которая для одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов (кроме log() и trace()). Такие функции являются кандидатами на мемоизацию.
